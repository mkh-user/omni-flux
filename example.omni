# OmniFlux example code
# This file shows basic syntax for OmniFlux language.

# Class name is optional
class Example
# "extends" defines parent class.
# When parent class is "Object" class, this line is optional, was added here to clear the concept.
extends Object

# This line is a comment.
"And this line"
"""
Also this lines
are comment
"""

"""
OmniFlux standrard interpretes support docstring conversion, and you
can use [b]BBCode[/b] in your comments to improve formatting.

Docstrings can be used to describe properties at defenition (decleration) time. 
Multiline docstring (docstring means both [code]#[/code] and string-based
comments) will be merged.

Here is an example:
"""

# This is language name. [b]Omni[/b] means universal and [b]Flux[/b] is both
# flow and flexibility.[br]
# This description provides example for docstring comments
const NAME = "OmniFlux"

# Red: FIXME, CAUTION, DEBUG;
# Yellow: NOTE, REFACTOR, OPTIMIZE, DEADLINE, PRIORITY;
# Green: ASSIGNED_TO, REVIEW, LAST_UPDATE, CATEGORY;
# Will be highlighted for better comment structure, search, and management.

# Also supports code regions:
#region Region Name
# Manage code and have smoother navigation with code regions.
#endregion

# Every constant, variable, and function starting with "_" is private property, others are public.

# Constant values can be defined with "const" keyword, you can use them to avoid magic values in your code.
# Use UPPER_SNAKE_CASE for constant names.
const PI = 3.14

# A constant without value is valid, but not recommended.
# Use "none" for empty values:
const HAS_PI = PI != none

# OmniFlux supports both dynamic and static typing, but constants types will be static anyway.
# Both following commented codes do same thing as next code, but last one is most recommended way.
# In all lines, GREETING will be a static value with string type, since constant's value can't be changed, its type is static.
#const GREETING: string = "Hello, World!" # <- Manual static type
#const GREETING := "Hello, World!" # <- Automatic static type
const GREETING = "Hello, World!"

# Variables can be defined with "var" keyword, variables can be static or dynamic typed:
# This variable is dynamic typed, supports any value of any type:
var name = "Ali" # Yes, OmniFlux is case sensetive, also NAME is a constant and name is a variable here
# This value is manually static typed, supports only integer values:
var _static_typed: int = 53
# This variable is none and dynamic typed, will be none until assignment:
var none_by_default
# This a none variable too, but is static typed and supports only array value:
var none_array: array
# This is automatic static typed variable, type will be float:
var auto_type := -1.9

# You can change value of a variable with [code]variable = value[/code] pattern.
# Valid, [var name] is dynamic typed
name = 12
# Invalid, [var _static_typed] is integer, not string
#_static_typed = "-7" # <- ValueError
# Valid
none_by_default = ["A"]
# Valid, value will be parsed before assignment
none_by_default = {"A": none_by_default}
# Valid, [var _static_typed] is integer, but [code]none[/code] can be passed to any variable
_static_typed = none_array
# Valid, 1 will be parsed to 1.0 automatically (just for int -> float)
auto_type = 1

# Also supports optional setter and getters:
var activation_state: state[3] = none:
	set(new_state: state[3]) -> void:
		if new_state == true:
			print("Activated")
		elif new_state == false:
			print("Activation Failed!")
		else:
			print("Reset activation state...")
		activation_state = new_state
	get(force_value := false) -> string: # Can get parameters!
		if activation_state == true:
			return "Completed"
		elif activation_state == false or force_value:
			return "Failed"
		else:
			return "Not Started"

# Variables with customized setter and getter (setter with more or less than 1 argument and getter with any argument) should be used like this:
Example.get("activation_state", true)
# Or in current class:
get("activation_state", false)
# [var activation_state] setter is standard, so can be used simply:
activation_state = true

# Multiple assignments at same time is supported like Python (with tuples under the hood):
name, _static_typed, none_by_default = "Joe", -100, none

# OmniFlux supports a wide range of value types.

# Note: AST was used as "Automatic Static Type" ([code]:=[/code] assignments) in following section.
# "AST is limited" means you can't use direct value in AST assignment but a value from given type can be passed to AST. Following example shows this behavior for states:
#     var your_state: state[4] = 3
#     # We want to set same value with static type for my_state:
#     var my_state := 3 # Incorrect, Will be integer!
#     var my_state := your_state # Correct, your_state is a state, so my_state will be a state.

# - Basic types

# 1. Variant
# Accepts any type, this is data type of dynamic typed variables.
# Can be used with ": variant" but isn't recommended.
# AST isn't supported. (Will be passed to given type instead of variant)
# Can be used in function return type to say this function has return value (Compared to "void").
var variant_variable = 10
func get_value() -> Variant: # Returns an unknown typed value
    # Functions will be explained later.
    pass

# 2. None
# Represents the absence of a value. Default value for uninitialized variables and constants.
# Can be assigned to any variable regardless of type, Used in conditions as a third state (besides true and false).
# Can't be used with ": none".
# AST isn't supported.
var none_by_default

# 3. Void
# Just for return type of functions without any return. Isn't valid as variable type.
# Can't be used with ": void".
# AST isn't supported.
func exit() -> void:
    pass

# 4. Boolean
# `true` and `false` are booleans.
# `and`, `or`, and `not` operators are available.
# Names stating with "is_", "has_", etc. are recommended for booleans.
# Important: false isn't equal to none in OmniFlux!
# Can be used with ": bool".
# AST is supported.
var is_night := false

# 5. Integer
# Can be used with ": int".
# AST is supported.
var year := 2025

# 6. Float
# Can be used with ": float".
# AST is supported.
var temperature := 26.5
var e := 16e-24

# 7. Complex number
# Can be used with ": complex".
# AST is supported.
var complex_number := 3+4i

# 8. Array
# Index based container.
# Can be used with ": array".
# AST is supported.
# Supports typed items, AST is limited for typed arrays.
# Items are accesible with [] by index.
var array := [1, 2, 3]
var typed_array: array[int] = [3, 2, 1]
# [code]range()[/code] function is an array generator:
var steped_r := range(1, 7, 2) # 1, 3, 5

# 9. Tuple
# Index based container with specified size.
# Can be used with ": tuple", ": tuple[size]".
# ": tuple" can't be used without value.
# AST is supported.
# Supports typed items, AST is limited for typed arrays.
# Size should be more than 0.
# Items are accesible with [] by index.
var user_1: tuple = (31, "Joe", false) # A tuple with three untyped items
#var empty_tuple: tuple # <- Invalid
var empty_tuple: tuple[2] # A tuple with two untyped items
var button_size: tuple[3, float] # A tuple with three typed (float) items (all are none for now)
var user_2: tuple[int, string, bool] = (42, "Hello", true) # A tuple with three typed items (from diffrenet types)

# 10. Set
# Existence based container with unique items.
# Can be used with ": set".
# AST is supported.
# Supports typed items, AST is limited for typed sets.
# Items are accesible with converting to array.
var prime_numbers: set[int] = {2, 3, 5, 7, 2} # Second 2 will be removed without error

# 11. Char
# A single character.
# Can be used with ": char".
# AST is limited. (Will be passed to string)
# ' is more recommended than ", both are supported.
var ltter: char = 'A'

# 12. String
# Array of chars.
# Can be used with ": string".
# AST is supported.
# " is more recommended than ', both are supported.
var font := "Vazirmatn"

# 13. Dictionary
# Key based container.
# Can be used with ": dict".
# AST is supported.
# Supports typed items, AST is limited for typed dictionaries.
# Items are accessible with [] by key.
var passwords: dict[string, string] = {"Admin": "1234", "User1": "cx?!@63"}

# 14. Callable function
# A reusable function.
# Can be used with ": function".
# AST is supported.
# Usable with call() method.
var to_int: function = func(data: string) -> int: return int(data)

# - Advanced types

# 15. N-base state
# Limited integer values in a range.
# Value is an integer.
# Can be used with ": state[number_of_states]".
# AST is limited. (Will be passed to integer)
# Number of states should be greater than 2.
var type: state[4] # 0, 1, 2, or 3

# 16. Pair & Triplet
# Most useful types of tuples. Index based container with 2 (pair) or 3 (triplet) size.
# Can be used with ": pair" and ": triplet".
# AST is limited. (Will be passed to tuple)
# Supports typed items, AST is limited for typed pairs and triplets.
# Items are accesible with [] by index and with .:
# door_1_size.x <-> door_1_size[0]
# door_1_size.y <-> door_1_size[1]
# pos.x <-> pos[0]
# pos.y <-> pos[1]
# pos.z <-> pos[2]
var door_1_size: pair = (3, 10) # Untyped items
var door_2_size: pair[float] = (4, 9) # Float items, will be (4.0, 9.0)
var file_size: pair[float, string] = (5.4, "MB") # Typed items, first should be float and second should be string.
# Same are supported for triplets: untyped, single type, multiple types.
var pos: triplet[int] = (3, -10, 0) # Integer items

# 17. Mutli-dimensional array
# Array with multiple dimensions. Size of all arrays in each dimension should be same.
# Can be used with ": mdarray[dimensions]".
# AST is limited. (Will be parsed to array)
# Supports typed items, AST is limited for typed mdarrays.
# Items are accesible with multiple [] by index.
var cube: mdarray[2, float] = [
	[
		[1.3,2,5],
		[-6,0.1,7.5],
	], [
		[5,-2.0,0.34],
		[0,0,14]
	], [
		[6,1.0,-100],
		[0.5,0.5,0.5],
	],
]

# 18. Table
# Array of arrays.
# Can be used with ": table" and ": table[columns]".
# ": table" can't be used without value.
# AST is limited. (Will be parsed to array)
# Supports typed items, AST is limited for typed tables.
# First row can be header (With any type of items).
# Items are accessible with two [] (second axis is also accessible with column name in header).
var data: table[4, string, int, string, string] = [
	["UserID", "Age", "Username", "Password"],
	["U_54xC", 21, "Max", "M2002X"],
	["U_3z62", 23, "Joe", "LaT3X!01"],
] # A table with 4 typed columns.

# 19. Queue
# A queue array. Add at the end, remove from the first.
# Can be used with ": queue".
# AST is limited. (Will be parsed to array)
# Supports typed items, AST is limited for typed queues.
# Items are accessible with [] by index, but standard way is enqueue() and dequeue() functions.
var tasks: queue[string] = []
tasks.enqueue("Task 1") # ["Task 1"]
tasks.enqueue("Task 2") # ["Task 1", "Task 2"]
print(tasks.dequeue()) # prints "Task 1", tasks will be: ["Task 2"]

# 20. Color
# Special tuple for colors (with 4 items).
# Can be used with ": color".
# AST is limited. (Will be parsed to tuple)
# Items are accessible with [] by index and with .:
# bg.r <-> bg[0]
# bg.g <-> bg[1]
# bg.b <-> bg[2]
# bg.a <-> bg[3]
var bg: color = (0.8, 0.7, 0.6) # Normal
var overlay: color = (1, 1, 1, 0.5) # With alpha
var red := color.RED # Named colors
var blue := color(0, 0, 1) # By constructor

# --- End of types section ---

# Functions will be defined with "func" keyword, a function can have any count of parameters (also called argument) and one optional return value.
# Like Python, multiple return values can be passed as tuple like multiple assignments.
# Overloading is supported.
# "..." can be used to pass any count of parameters.
# Parameters can be passed by name (with "=").
# All functions are available as callable in parent object's variables and can be called by "call()" function.
func _on_data_received(data: string) -> void:
    print(f"Data received: {data}")

func sum(...nums: array[int]) -> int:
	var sum: int = 0
	for i in nums:
		sum += i
	return sum

call(sum, 4, 5) # Returns 9

# Lambda functions can be used as value for variables or even as parameter in a function directly.
var to_int: function = func(data: string) -> int: return int(data)

# Signals provide trackable events:
signal data_received(data: string)

data_received.connect(_on_data_received) # See above section for _on_data_received

data_received.emit("Test")

# Enumerations are supported with "enum" keyword.
# Anonymous enums are supported, items of these enums can be used directly.
# Items of named enums should be used with enum name. These enums can be used as data type.
# "@anonymous_shadow" annotation provides a way to use items of these enums directly.
# Anonymous enum
enum:
    ON, # 0
    OFF, # 1
    BOTH, # 2, Last "," is optional but recommended

print(OFF) # 1

@anonymous_shadow # Will be accessible without [code]Error.[/code] prefix.
enum Error:
    OK, # 0
    ERROR, # 1

print(OK) # 0
print(Error.OK) # 0

enum States:
	DAY, # 0
	NIGHT = 6,
	MIDNIGHT = 11,
	MORNING, # 12 (from last)

print(States.DAY) # 0
#print(DAY) # <- Error, doesn't exist!

# Named enums can be used as type:
var time: States = States.DAY

# "pass" keyword can be used to 

# Conditions can be excuted with "if", "elif", and "else":
if is_here:
    pass
elif is_valid:
    pass
else:
    pass